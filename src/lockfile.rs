use std::collections::HashSet;
use std::fmt;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::str::FromStr;

use crate::package::Dependency;
use crate::{ConfigDependency, Repository, ResolvedDependency, Version};
use fs_err as fs;
use serde::Deserialize;
use toml_edit::{Array, ArrayOfTables, InlineTable, Item, Table, Value};

const CURRENT_LOCKFILE_VERSION: i64 = 1;
const INITIAL_COMMENT: &str = r#"# This file is automatically @generated by rv.
# It is not intended for manual editing.
"#;

#[derive(PartialEq, Eq, Clone, Deserialize)]
#[serde(untagged)]
pub enum Source {
    /// we keep the repository url alongside the git info, but is treated as a Git source
    RUniverse {
        repository: String,
        git: String,
        sha: String,
        directory: Option<String>,
    },
    Git {
        git: String,
        sha: String,
        directory: Option<String>,
        /// We keep tag and branch around to quickly compare with the config file, eg
        /// if the tag changed in the config file we know that it will require an update without
        /// having to look up anything
        tag: Option<String>,
        branch: Option<String>,
    },
    Url {
        url: String,
        sha: String,
    },
    Repository {
        repository: String,
    },
    Local {
        path: PathBuf,
        /// Only for tarballs
        sha: Option<String>,
    },
}

impl Source {
    fn as_toml_table(&self) -> InlineTable {
        let mut table = InlineTable::new();

        match self {
            Self::Git {
                git,
                sha,
                directory,
                tag,
                branch,
            } => {
                table.insert("git", Value::from(git));
                table.insert("sha", Value::from(sha));
                if let Some(d) = directory {
                    table.insert("directory", Value::from(d));
                }
                if let Some(d) = tag {
                    table.insert("tag", Value::from(d));
                }
                if let Some(d) = branch {
                    table.insert("branch", Value::from(d));
                }
            }
            Self::Url { url, sha } => {
                table.insert("url", Value::from(url));
                table.insert("sha", Value::from(sha));
            }
            Self::Repository { repository } => {
                table.insert("repository", Value::from(repository));
            }
            Self::Local { path, sha } => {
                table.insert("path", Value::from(path.display().to_string()));
                if let Some(s) = sha {
                    table.insert("sha", Value::from(s));
                }
            }
            Self::RUniverse {
                repository,
                git,
                sha,
                directory,
            } => {
                table.insert("repository", Value::from(repository));
                table.insert("git", Value::from(git));
                table.insert("sha", Value::from(sha));
                if let Some(d) = directory {
                    table.insert("directory", Value::from(d));
                }
            }
        };

        table
    }

    pub fn is_git_or_url(&self) -> bool {
        // we treat RUniverse like Git
        matches!(
            self,
            Source::Git { .. } | Source::Url { .. } | Source::RUniverse { .. }
        )
    }

    pub fn is_repo(&self) -> bool {
        matches!(self, Source::Repository { .. })
    }

    /// The key to use in the cache: URL for a package repository, git URL for a git repository
    /// and for local the actual path
    pub fn source_path(&self) -> &str {
        match self {
            Source::Repository { ref repository } => repository.as_str(),
            Source::Local { ref path, .. } => path.to_str().unwrap(),
            Source::Git { ref git, .. } | Source::RUniverse { ref git, .. } => git.as_str(),
            Source::Url { ref url, .. } => url.as_str(),
        }
    }

    pub fn sha(&self) -> &str {
        match self {
            Source::Git { ref sha, .. } | Source::RUniverse { ref sha, .. } => sha.as_str(),
            Source::Url { ref sha, .. } => sha.as_str(),
            _ => unreachable!("handle other cases"),
        }
    }

    /// Some sources might have changed remotely so we will want to fetch them to be sure it
    /// hasn't changed (eg a git branch having new commits)
    pub fn could_have_changed(&self) -> bool {
        match self {
            Source::Git { tag, branch, .. } => tag.is_some() || branch.is_some(),
            Source::Url { .. } => true,
            _ => false,
        }
    }

    pub fn is_matching(&self, dep: &ConfigDependency) -> bool {
        // TODO: verify all that + add tests
        match (self, dep) {
            (
                Source::Git {
                    git,
                    directory,
                    tag,
                    branch,
                    sha,
                },
                ConfigDependency::Git {
                    git: git2,
                    commit,
                    directory: directory2,
                    branch: branch2,
                    tag: tag2,
                    ..
                },
            ) => {
                if git != git2 || directory != directory2 || branch != branch2 || tag != tag2 {
                    return false;
                }
                if let Some(sha2) = commit {
                    if sha2.len() == 7 {
                        return sha[..7] == *sha2;
                    } else {
                        return sha == sha2;
                    }
                }
                true
            }
            (Source::Url { url: url1, .. }, ConfigDependency::Url { url: url2, .. }) => {
                url1 == url2
            }
            (Source::Local { path: p1, .. }, ConfigDependency::Local { path: p2, .. }) => p1 == p2,
            (
                Source::Repository { repository: r1 },
                ConfigDependency::Detailed { repository: r2, .. },
            ) => {
                // We are only comparing the repositories here
                r2.as_ref().map(|r| r == r1).unwrap_or(true)
            }
            (Source::Repository { .. }, ConfigDependency::Simple(..)) => true,
            (
                Source::RUniverse { repository: r1, .. },
                ConfigDependency::Detailed { repository: r2, .. },
            ) => r2.as_ref().map(|r| r == r1).unwrap_or(true),
            (Source::RUniverse { .. }, ConfigDependency::Simple(..)) => true,
            _ => false,
        }
    }
}

impl fmt::Debug for Source {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Git {
                git,
                sha,
                directory,
                tag,
                branch,
            } => {
                write!(f, "git(url: {git}, sha: {sha}, directory: {directory:?}, tag: {tag:?}, branch: {branch:?})")
            }
            Self::Repository { repository } => {
                write!(f, "repository(url: {repository})")
            }
            Self::Local { path, sha } => {
                if let Some(sha) = sha {
                    write!(f, "local(path: {}, sha: {sha})", path.display())
                } else {
                    write!(f, "local(path: {})", path.display())
                }
            }
            Self::Url { url, sha } => {
                write!(f, "url(url: {url}, sha:{sha})")
            }
            Self::RUniverse {
                repository,
                git,
                sha,
                directory,
            } => {
                write!(f, "runiverse(repo: {repository}, url: {git}, sha: {sha}, directory: {directory:?})")
            }
        }
    }
}

impl fmt::Display for Source {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Git {
                git,
                sha,
                tag,
                branch,
                ..
            } => {
                if let Some(branch) = branch {
                    write!(f, "{git} (branch: {branch})")
                } else if let Some(tag) = tag {
                    write!(f, "{git} (tag: {tag})")
                } else {
                    write!(f, "{git} (commit: {sha})")
                }
            }
            Self::Repository { repository } => {
                write!(f, "{repository}")
            }
            Self::Local { path, .. } => {
                write!(f, " {}", path.display())
            }
            Self::Url { url, .. } => {
                write!(f, "{url}")
            }
            Self::RUniverse { git, sha, .. } => {
                write!(f, "{git} (commit: {sha})")
            }
        }
    }
}

fn format_array(deps: &[Dependency]) -> Array {
    let mut deps = deps
        .iter()
        .map(|d| {
            let mut value = d.as_toml_value();
            value.decor_mut().set_prefix("\n    ");
            value
        })
        .collect::<Array>();
    deps.set_trailing_comma(true);

    // Closing ] on its own line if we have at least one dep
    if !deps.is_empty() {
        deps.set_trailing("\n");
    }

    deps
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub struct LockedPackage {
    pub name: String,
    pub version: String,
    pub source: Source,
    pub path: Option<String>,
    pub force_source: bool,
    pub dependencies: Vec<Dependency>,
    /// Only filled if the package had install_suggests=True in the config file
    #[serde(default)]
    pub suggests: Vec<Dependency>,
}

impl LockedPackage {
    pub fn from_resolved_dep(dep: ResolvedDependency) -> Self {
        Self {
            name: dep.name.into_owned(),
            version: dep.version.original.clone(),
            source: dep.source,
            path: dep.path.map(|p| p.into_owned()),
            force_source: dep.force_source,
            dependencies: dep
                .dependencies
                .into_iter()
                .map(|x| x.into_owned())
                .collect(),
            suggests: dep.suggests.into_iter().map(|x| x.into_owned()).collect(),
        }
    }

    fn as_toml_table(&self) -> Table {
        let mut table = Table::new();
        table.insert("name", Item::Value(Value::from(&self.name)));
        table.insert("version", Item::Value(Value::from(&self.version)));
        table.insert(
            "source",
            Item::Value(Value::InlineTable(self.source.as_toml_table())),
        );
        if let Some(p) = &self.path {
            table.insert("path", Item::Value(Value::from(p)));
        }
        table.insert("force_source", Item::Value(Value::from(self.force_source)));
        table.insert(
            "dependencies",
            Item::Value(Value::Array(format_array(&self.dependencies))),
        );
        if !self.suggests.is_empty() {
            table.insert(
                "suggests",
                Item::Value(Value::Array(format_array(&self.suggests))),
            );
        }

        table
    }

    pub fn install_suggests(&self) -> bool {
        !self.suggests.is_empty()
    }

    pub fn is_matching(&self, dep: &ConfigDependency, repo_urls: &HashSet<&str>) -> bool {
        if dep.install_suggestions() && !self.install_suggests() {
            return false;
        }

        if let Source::Repository { ref repository } = self.source {
            if !repo_urls.contains(repository.as_str()) {
                return false;
            }
        }

        true
    }
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub struct Lockfile {
    version: i64,
    r_version: String,
    packages: Vec<LockedPackage>,
    // TODO: benchmark if we need a quick pkg_name -> idx in array lookup table with a big project
}

impl Lockfile {
    pub fn new(r_version: &str) -> Self {
        Self {
            version: CURRENT_LOCKFILE_VERSION,
            r_version: r_version.to_string(),
            packages: vec![],
        }
    }

    /// Ensures we have the full dependency graph as data. If we are missing even one thing then the
    /// lockfile is considered invalid.
    fn validate(&self) -> Result<(), LockfileError> {
        let package_names = self.package_names();
        let mut not_found = HashSet::new();

        for p in &self.packages {
            for d in &p.dependencies {
                if !package_names.contains(d.name()) {
                    not_found.insert(d.name());
                }
            }
        }

        if !not_found.is_empty() {
            return Err(LockfileError {
                source: LockfileErrorKind::Invalid(format!(
                    "Missing dependencies in the lockfile: {}",
                    not_found.into_iter().collect::<Vec<_>>().join(", ")
                )),
            });
        }

        Ok(())
    }

    pub fn from_resolved(r_version: &[u32; 2], deps: Vec<ResolvedDependency>) -> Self {
        let mut packages: Vec<_> = deps
            .into_iter()
            .map(LockedPackage::from_resolved_dep)
            .collect();
        packages.sort_unstable_by(|a, b| a.name.cmp(&b.name));

        Self {
            version: CURRENT_LOCKFILE_VERSION,
            r_version: format!("{}.{}", r_version[0], r_version[1]),
            packages,
        }
    }

    pub(crate) fn as_toml_string(&self) -> String {
        let mut doc = toml_edit::DocumentMut::new();
        doc.insert("version", Item::Value(Value::from(self.version)));
        doc.insert("r_version", Item::Value(Value::from(&self.r_version)));

        let mut packages = ArrayOfTables::new();
        for p in self.packages.iter() {
            packages.push(p.as_toml_table());
        }
        doc.insert("packages", Item::ArrayOfTables(packages));

        let mut out = String::new();
        out.push_str(INITIAL_COMMENT);
        out.push_str(&doc.to_string());

        out
    }

    pub fn save(&self, path: impl AsRef<Path>) -> Result<(), LockfileError> {
        self.validate()?;

        let out = self.as_toml_string();

        let mut file = File::create(path.as_ref()).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;
        file.write_all(out.as_bytes()).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;

        Ok(())
    }

    pub fn load(path: impl AsRef<Path>) -> Result<Self, LockfileError> {
        let content = fs::read_to_string(path).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;
        let data: Self = toml::from_str(&content).map_err(|e| LockfileError {
            source: LockfileErrorKind::Toml(e),
        })?;

        data.validate()?;
        Ok(data)
    }

    /// Try to look up a package in the lockfile
    /// If it gets passed a dependency, it means it is a user provided. If it isn't, then we only
    /// look up by name
    pub fn get_package(
        &self,
        name: &str,
        dep: Option<&ConfigDependency>,
    ) -> Option<&LockedPackage> {
        if let Some(p) = self.packages.iter().find(|p| p.name == name) {
            if let Some(d) = dep {
                if p.source.is_matching(d) {
                    return Some(p);
                }
            } else {
                return Some(p);
            }
        }

        None
    }

    /// Returns the full dependency tree (including itself) for a given package
    /// If the return set is empty, it means the package with the given name was not found.
    /// The lockfile has been validated after loading it so all the deps should be present in it.
    pub fn get_package_tree(&self, name: &str, dep: Option<&ConfigDependency>) -> HashSet<&str> {
        if let Some(p) = self.get_package(name, dep) {
            let mut out = HashSet::new();
            out.insert(p.name.as_str());
            for p in &p.dependencies {
                out.extend(self.get_package_tree(p.name(), None));
            }
            out
        } else {
            HashSet::new()
        }
    }

    /// Returns whether the lockfile is enough to resolve all the deps given or whether
    /// we'll need to look up the databases
    pub fn can_resolve(&self, deps: &[ConfigDependency], repos: &[Repository]) -> bool {
        let repo_urls = repos.iter().map(|x| x.url()).collect::<HashSet<_>>();
        for d in deps {
            if let Some(pkg) = self.get_package(d.name(), Some(d)) {
                if !pkg.is_matching(d, &repo_urls) {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }

    pub fn contains_resolved_dep(&self, dep: &ResolvedDependency) -> bool {
        self.packages
            .iter()
            .find(|lock_pkg| {
                lock_pkg.name == dep.name.as_ref()
                    && lock_pkg.version == dep.version.as_ref().original
            })
            .is_some()
    }

    /// Gets a set of all the package names listed in the lockfile
    pub fn package_names(&self) -> HashSet<&str> {
        let mut out = HashSet::new();
        for p in &self.packages {
            out.insert(p.name.as_str());
        }
        out
    }

    /// Returns the parsed Version of the R version listed in the lockfile
    pub fn r_version(&self) -> Version {
        Version::from_str(&self.r_version.to_string()).unwrap()
    }
}

impl FromStr for Lockfile {
    type Err = LockfileError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let data: Self = toml::from_str(s).map_err(|e| LockfileError {
            source: LockfileErrorKind::Toml(e),
        })?;

        data.validate()?;
        Ok(data)
    }
}

#[derive(Debug, thiserror::Error)]
#[error("Lockfile error: {source}")]
#[non_exhaustive]
pub struct LockfileError {
    pub source: LockfileErrorKind,
}

#[derive(Debug, thiserror::Error)]
pub enum LockfileErrorKind {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Toml(#[from] toml::de::Error),
    #[error("Invalid lockfile: {0}")]
    Invalid(String),
}

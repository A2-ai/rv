use fs_err as fs;
use serde::Deserialize;
use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::str::FromStr;
use toml_edit::{Array, ArrayOfTables, InlineTable, Item, Table, Value};

use crate::{ResolvedDependency, Version};

const CURRENT_LOCKFILE_VERSION: i64 = 1;
pub const FILENAME: &str = "rv.lock";
const INITIAL_COMMENT: &str = r#"# This file is automatically @generated by rv.
# It is not intended for manual editing.
"#;

#[derive(Debug, PartialEq, Clone, Deserialize)]
#[serde(untagged)]
pub enum Source {
    Git { git: String },
    Repository { repository: String },
    Local { path: String },
}

impl Source {
    fn as_toml_table(&self) -> InlineTable {
        let mut table = InlineTable::new();

        match self {
            Self::Git { git } => table.insert("git", Value::from(git)),
            Self::Repository { repository } => table.insert("repository", Value::from(repository)),
            Self::Local { path } => table.insert("path", Value::from(path)),
        };

        table
    }
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub struct LockedPackage {
    // Lowercased
    pub name: String,
    pub version: String,
    source: Option<Source>,
    pub path: Option<String>,
    pub force_source: bool,
    pub dependencies: Vec<String>,
}

impl LockedPackage {
    pub fn from_resolved_dep(dep: &ResolvedDependency) -> Self {
        Self {
            name: dep.name.to_string(),
            version: dep.version.to_string(),
            source: Some(Source::Repository {
                repository: dep.repository_url.to_string(),
            }),
            path: dep.path.cloned(),
            force_source: dep.force_source,
            dependencies: dep.dependencies.iter().map(|d| d.to_string()).collect(),
        }
    }

    fn as_toml_table(&self) -> Table {
        let mut table = Table::new();
        table.insert("name", Item::Value(Value::from(&self.name)));
        table.insert("version", Item::Value(Value::from(&self.version)));
        if let Some(s) = &self.source {
            table.insert("source", Item::Value(Value::InlineTable(s.as_toml_table())));
        }
        if let Some(p) = &self.path {
            table.insert("path", Item::Value(Value::from(self.force_source)));
        }
        table.insert("force_source", Item::Value(Value::from(self.force_source)));
        let mut deps = self
            .dependencies
            .iter()
            .map(|d| {
                let mut value = Value::from(d);
                value.decor_mut().set_prefix("\n    ");
                value
            })
            .collect::<Array>();
        deps.set_trailing_comma(true);
        // Closing ] on its own line if we have at least one dep
        if !self.dependencies.is_empty() {
            deps.set_trailing("\n");
        }
        table.insert("dependencies", Item::Value(Value::Array(deps)));

        table
    }

    // TODO: tmp, to be generalized later when we have git handling
    pub fn repo_url(&self) -> Option<&str> {
        match &self.source {
            Some(Source::Repository { repository }) => Some(repository.as_str()),
            _ => None,
        }
    }
}

#[derive(Debug, Deserialize, Clone, PartialEq)]
pub struct Lockfile {
    version: i64,
    r_version: String,
    packages: Vec<LockedPackage>,
    // TODO: benchmark if we need a quick pkg_name -> idx in array lookup table with a big project
}

impl Lockfile {
    pub fn new(r_version: &str) -> Self {
        Self {
            version: CURRENT_LOCKFILE_VERSION,
            r_version: r_version.to_string(),
            packages: vec![],
        }
    }

    /// Ensures we have the full dependency graph as data. If we are missing even one thing then the
    /// lockfile is considered invalid.
    fn validate(&self) -> Result<(), LockfileError> {
        let package_names = self.package_names();
        let mut not_found = HashSet::new();

        for p in &self.packages {
            for d in &p.dependencies {
                if !package_names.contains(d.as_str()) {
                    not_found.insert(d.as_str());
                }
            }
        }

        if !not_found.is_empty() {
            return Err(LockfileError {
                source: LockfileErrorKind::Invalid(format!(
                    "Missing dependencies in the lockfile: {}",
                    not_found.into_iter().collect::<Vec<_>>().join(", ")
                )),
            });
        }

        Ok(())
    }

    pub fn from_resolved(r_version: &[u32; 2], deps: &[ResolvedDependency]) -> Self {
        let mut packages: Vec<_> = deps.iter().map(LockedPackage::from_resolved_dep).collect();
        packages.sort_unstable_by(|a, b| a.name.cmp(&b.name));

        Self {
            version: CURRENT_LOCKFILE_VERSION,
            r_version: format!("{}.{}", r_version[0], r_version[1]),
            packages,
        }
    }

    pub(crate) fn as_toml_string(&self) -> String {
        let mut doc = toml_edit::DocumentMut::new();
        doc.insert("version", Item::Value(Value::from(self.version)));
        doc.insert("r_version", Item::Value(Value::from(&self.r_version)));

        let mut packages = ArrayOfTables::new();
        for p in self.packages.iter() {
            packages.push(p.as_toml_table());
        }
        doc.insert("packages", Item::ArrayOfTables(packages));

        let mut out = String::new();
        out.push_str(INITIAL_COMMENT);
        out.push_str(&doc.to_string());

        out
    }

    pub fn save(&self, path: impl AsRef<Path>) -> Result<(), LockfileError> {
        self.validate()?;

        let out = self.as_toml_string();

        let mut file = File::create(path.as_ref()).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;
        file.write_all(out.as_bytes()).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;

        Ok(())
    }

    pub fn load(path: impl AsRef<Path>) -> Result<Self, LockfileError> {
        let content = fs::read_to_string(path).map_err(|e| LockfileError {
            source: LockfileErrorKind::Io(e),
        })?;
        let data: Self = toml::from_str(&content).map_err(|e| LockfileError {
            source: LockfileErrorKind::Toml(e),
        })?;

        data.validate()?;
        Ok(data)
    }

    pub fn get_package(&self, name: &str, force_source: bool) -> Option<&LockedPackage> {
        self.packages
            .iter()
            .find(|p| p.name == name && p.force_source == force_source)
    }

    /// Returns the full dependency tree (including itself) for a given package
    /// If the return set is empty, it means the package with the given name was not found.
    /// The lockfile has been validated after loading it so all the deps should be present in the
    /// lockfile.
    pub fn get_package_tree(&self, name: &str, force_source: bool) -> HashSet<&str> {
        if let Some(p) = self
            .packages
            .iter()
            .find(|p| p.name == name && p.force_source == force_source)
        {
            let mut out = HashSet::new();
            out.insert(p.name.as_str());
            for p in &p.dependencies {
                out.extend(self.get_package_tree(p.as_str(), false));
            }
            out
        } else {
            HashSet::new()
        }
    }

    /// Removes a package and all of its deps from the lockfile if they are not dependencies of
    /// another package.
    pub fn remove_package(&mut self, name: &str) {
        let mut to_remove = HashSet::new();

        if let Some(p) = self.packages.iter().find(|p| p.name == name) {
            let mut packages_to_remove =
                HashSet::from_iter(p.dependencies.iter().map(|d| d.as_str()));
            packages_to_remove.insert(name);
            let mut needs_to_be_kept = HashSet::new();

            for pkg in &self.packages {
                if packages_to_remove.contains(pkg.name.as_str()) {
                    continue;
                }
                for d in &pkg.dependencies {
                    if packages_to_remove.contains(d.as_str()) {
                        needs_to_be_kept.insert(d.as_str());
                    }
                }
            }

            for name in packages_to_remove.difference(&needs_to_be_kept) {
                to_remove.insert(name.to_string());
            }
        }

        self.packages.retain(|p| !to_remove.contains(&p.name));
        debug_assert!(self.validate().is_ok());
    }

    /// Gets a set of all the package names listed in the lockfile
    pub fn package_names(&self) -> HashSet<&str> {
        let mut out = HashSet::new();
        for p in &self.packages {
            out.insert(p.name.as_str());
        }
        out
    }

    /// Returns the parsed Version of the R version listed in the lockfile
    pub fn r_version(&self) -> Version {
        Version::from_str(&self.r_version.to_string()).unwrap()
    }
}

impl FromStr for Lockfile {
    type Err = LockfileError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let data: Self = toml::from_str(s).map_err(|e| LockfileError {
            source: LockfileErrorKind::Toml(e),
        })?;

        data.validate()?;
        Ok(data)
    }
}

#[derive(Debug, thiserror::Error)]
#[error("Lockfile error: {source}")]
#[non_exhaustive]
pub struct LockfileError {
    pub source: LockfileErrorKind,
}

#[derive(Debug, thiserror::Error)]
pub enum LockfileErrorKind {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Toml(#[from] toml::de::Error),
    #[error("Invalid lockfile: {0}")]
    Invalid(String),
}
